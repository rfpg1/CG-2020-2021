<html>

<head>
<title>WebGL Exercise</title>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<!-- CSS Styles //-->
<link href='css/styles.css'   type='text/css' rel='stylesheet'>
<link href='css/prettify_sunburst.css'  type='text/css' rel='stylesheet'/>
<link href='css/smoothness/jquery-ui-1.8.13.custom.css' type='text/css' rel='stylesheet' />
<!-- GUI Libraries //-->
<script type='text/javascript' src='js/gui/jquery-1.5.1.min.js'></script>
<script type='text/javascript' src='js/gui/jquery-ui-1.8.13.custom.min.js'></script> 
<script type='text/javascript' src='js/gui/prettify.js'></script>
<script type='text/javascript' src='js/gui/codeview.js'></script>
<!-- MATH Libraries //-->
<script type='text/javascript' src='js/math/gl-matrix-min.js'></script>
<!-- WEBGL Libraries //-->
<script type='text/javascript' src='js/webgl/Globals.js'></script>
<script type='text/javascript' src='js/webgl/Utils.js'></script>
<script type='text/javascript' src='js/webgl/Program.js'></script>
<script type='text/javascript' src='js/webgl/Scene.js'></script>
<script type='text/javascript' src='js/webgl/Axis.js'></script>
<script type='text/javascript' src='js/webgl/Floor.js'></script>
<script type='text/javascript' src='js/webgl/Camera.js'></script>
<script type='text/javascript' src='js/webgl/CameraInteractor.js'></script>
<script type='text/javascript' src='js/webgl/WebGLApp.js'></script>



<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec4 aVertexColor;
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat4 uNMatrix;
uniform bool uUpdateLight;
uniform vec3 uLightPosition; 
uniform vec4 uLightAmbient;  
uniform vec4 uLightDiffuse;  
uniform vec4 uMaterialDiffuse;
uniform bool uWireframe;
uniform bool uPerVertexColor;

varying vec4 vFinalColor;

void main(void) {

    if (uWireframe) {
        if (uPerVertexColor){
            vFinalColor = aVertexColor;
        }
        else{
            vFinalColor = uMaterialDiffuse;
        }
    }
    else{
        vec3 N = vec3(uNMatrix * vec4(aVertexNormal, 0.0));  // This is a vector w = 0;
        vec3 L = normalize(-uLightPosition);                 // Given a light position, use the inverse is the direction (to the center of the world)
        if(uUpdateLight){
            L = vec3(uNMatrix*vec4(L,0.0));   // vector light direction
        }
        
        float lambertTerm = dot(N,-L);
        if (lambertTerm == 0.0) lambertTerm = 0.01;
        vec4 Ia = uLightAmbient;
        vec4 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;
        vFinalColor = Ia + Id;
        vFinalColor.a = 1.0;
    }
    
    //Transformed vertex position
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0); // vertex w=1
    
}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

varying vec4  vFinalColor;

void main(void)  {
 gl_FragColor = vFinalColor;
}
</script>

<script id='code-js' type="text/javascript">

var PROJ_ORTHO = 0;
var PROJ_PERSPECTIVE = 1;
var projectionMode = PROJ_PERSPECTIVE;

/**
*   Defines the initial values for the transformation matrices
*/
function initTransforms(){
    //Initialize Model-View matrix
    mvMatrix = camera.getViewTransform();
    
    //Initialize Perspective matrix
    mat4.identity(pMatrix);
    
    //Initialize Normal matrix
    mat4.identity(nMatrix);
    mat4.set(mvMatrix, nMatrix);
    mat4.inverse(nMatrix);
    mat4.transpose(nMatrix);
    
 }

/**
*   Updates the Model-View matrix if there is any translation or change in 
*   coordinate system (world->camera or camera->world). Updates the Normal matrix according to the translation.
*   Please notice that the normal matrix will ALWAYS operate in world coordinates.
*   Called once per rendering cycle.
*/
var fovy = 30;
function updateTransforms(){
    if (projectionMode == PROJ_PERSPECTIVE){
        mat4.perspective(fovy, c_width / c_height, 1, 400.0, pMatrix);
    }
    else{
		cw = c_width/250;
		ch = c_height/250;
        mat4.ortho(-cw, cw, -ch, ch, -10.0, 10.0, pMatrix);
    }
}


/**
* Maps the matrices to shader matrix uniforms
*
* Called once per rendering cycle. 
*/
function setMatrixUniforms(){
    
    gl.uniformMatrix4fv(prg.uMVMatrix, false, camera.getViewTransform());        //Maps the Model-View matrix to the uniform prg.uMVMatrix
    
    gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);    //Maps the Perspective matrix to the uniform prg.uPMatrix
    
    mat4.transpose(camera.matrix, nMatrix);               //Calculates the Normal matrix 
    gl.uniformMatrix4fv(prg.uNMatrix, false, nMatrix);    //Maps the Normal matrix to the uniform prg.uNMatrix
    

}

/**
*  Configures the gl context
*/
var camera = null;
var interactor = null;

function configure(){
    
    gl.clearColor(0.0,0.3,0.7, 1.0);
    gl.clearDepth(100.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    
    //Creates and sets up the camera location
    camera = new Camera(CAMERA_TRACKING_TYPE);
    camera.goHome([1,1,8]);
    camera.hookRenderer = draw;
    
    //Creates and sets up the mouse and keyboard interactor
    var canvas = document.getElementById('canvas-element-id');
    interactor = new CameraInteractor(camera, canvas);
    
    //Update lights for this example
    gl.uniform4fv(prg.uLightAmbient,      [0.05,0.05,0.05,1.0]);
    gl.uniform3fv(prg.uLightPosition,     [1, 5, 2]);
    gl.uniform4fv(prg.uLightDiffuse,      [0.7,0.7,0.7,1.0]);
    
    //init gui with camera settings
    //initGUIWithCameraSettings();
    
    //init transforms
    initTransforms();
}


/**
* Loads the scene
*/
function load(){
    //Load the office building
	Scene.loadObjectByParts('models/geometry/Building/part','Office',758);
	//Load the ground
	Scene.loadObject('models/geometry/Building/plane.json','Plane');
	Scene.loadObject('models/geometry/Building/obj.json','Object');
}


/**
* invoked on every rendering cycle
*/
function draw() {
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
    try{
        
        updateTransforms();   
        setMatrixUniforms(); 
        
        gl.uniform1i(prg.uUpdateLight,updateLightPosition);
        
        for (var i = 0; i < Scene.objects.length; i++){
            
            var object = Scene.objects[i];
            
            //Setting uniforms
            gl.uniform4fv(prg.uMaterialDiffuse, object.diffuse);
            gl.uniform1i(prg.uWireframe,object.wireframe);
            gl.uniform1i(prg.uPerVertexColor, object.perVertexColor);
            
            //Setting attributes
            gl.enableVertexAttribArray(prg.aVertexPosition);
            gl.disableVertexAttribArray(prg.aVertexNormal);
            gl.disableVertexAttribArray(prg.aVertexColor);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
            gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(prg.aVertexPosition);
            
            if(!object.wireframe){
                gl.bindBuffer(gl.ARRAY_BUFFER, object.nbo);
                gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prg.aVertexNormal);
            }
            
            if (object.perVertexColor){
                gl.bindBuffer(gl.ARRAY_BUFFER, object.cbo);
                gl.vertexAttribPointer(prg.aVertexColor,4,gl.FLOAT, false, 0,0);
                gl.enableVertexAttribArray(prg.aVertexColor);
            }
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);
            
            if (object.wireframe){
                gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT,0);
            }
            else{
                gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT,0);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            
        }
    
        
    // Set the drawing position to the "identity" point, which is
    // the center of the scene.
    const modelViewMatrixCube = mat4.create();

    // Now move the drawing position a bit to where we want to
    // start drawing the square.

    mat4.translate(modelViewMatrixCube,     // destination matrix
    modelViewMatrixCube,     // matrix to translate
                [0.0, 50.0, 0.0]);  // amount to translate
    /*
    mat4.rotate(modelViewMatrixCube,  // destination matrix
    modelViewMatrixCube,  // matrix to rotate
                cubeRotation * .7,// amount to rotate in radians
                [0, 1, 0]);       // axis to rotate around (X)
    */
   
    const normalMatrixCube = mat4.create();
    mat4.inverse(normalMatrixCube, modelViewMatrixCube);
    mat4.transpose(normalMatrixCube, normalMatrixCube);

    // Tell WebGL how to pull out the positions from the position
    // buffer into the vertexPosition attribute
    {
    const numComponents = 3;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    const offset = 0;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[0].position);
    gl.vertexAttribPointer(
        prg.vertexPosition,
        numComponents,
        type,
        normalize,
        stride,
        offset);
    gl.enableVertexAttribArray(
        prg.vertexPosition);
    }

    // Tell WebGL how to pull out the colors from the color buffer
    // into the vertexColor attribute.
    {
    const numComponents = 4;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    const offset = 0;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[0].color);
    gl.vertexAttribPointer(
        prg.vertexColor,
        numComponents,
        type,
        normalize,
        stride,
        offset);
    gl.enableVertexAttribArray(
        prg.vertexColor);
    }

    // Tell WebGL how to pull out the normals from
    // the normal buffer into the vertexNormal attribute.
    {
    const numComponents = 3;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    const offset = 0;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers[0].normal);
    gl.vertexAttribPointer(
        prg.vertexNormal,
        numComponents,
        type,
        normalize,
        stride,
        offset);
    gl.enableVertexAttribArray(
        prg.vertexNormal);
    }

    // Tell WebGL which indices to use to index the vertices
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers[0].indices);

    // Tell WebGL to use our program when drawing

    gl.useProgram(prg);

    // Set the shader uniforms

    gl.uniformMatrix4fv(
        prg.uPMatrix,
        false,
        pMatrix);
    gl.uniformMatrix4fv(
        prg.uMVMatrix,
        false,
        modelViewMatrixCube);
        
    gl.uniformMatrix4fv(
        prg.uNMatrix,
        false,
        normalMatrixCube);

    {
    const vertexCount = 36;
    const type = gl.UNSIGNED_SHORT;
    const offset = 0;
    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
    }

    // Update the rotation for the next draw

    //cubeRotation += deltaTime;
    
    }
    catch(err){
        alert(err);
        console.error(err.description);
    }
}

/**
* Entry point. This function is invoked when the page is loaded
*/
var app = null;
var buffers = null;
var programInfo = null;
function runWebGLApp() {
    app = new WebGLApp("canvas-element-id")
    app.configureGLHook = configure;
    app.loadSceneHook   = load;
    app.drawSceneHook   = draw;
    buffers = initBuffers();
    console.log(buffers);
    //programInfo = initProgram();
    console.log(prg);
    app.run();
}

function initProgram(){
    return {
    program: shaderProgram,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
      vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
      vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
      modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
      normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
      uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
    }
  };
}

function initBuffers() {
  var result = [];
  // Create a buffer for the cube's vertex positions.

  const positionBufferCube = gl.createBuffer();

  // Select the positionBuffer as the one to apply buffer
  // operations to from here out.

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBufferCube);

  // Now create an array of positions for the cube.

  const positionsCube = [
    // Front face
    -1.0, -1.0,  1.0,
     1.0, -1.0,  1.0,
     1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,

    // Back face
    -1.0, -1.0, -1.0,
    -1.0,  1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0, -1.0, -1.0,

    // Top face
    -1.0,  1.0, -1.0,
    -1.0,  1.0,  1.0,
     1.0,  1.0,  1.0,
     1.0,  1.0, -1.0,

    // Bottom face
    -1.0, -1.0, -1.0,
     1.0, -1.0, -1.0,
     1.0, -1.0,  1.0,
    -1.0, -1.0,  1.0,

    // Right face
     1.0, -1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0,  1.0,  1.0,
     1.0, -1.0,  1.0,

    // Left face
    -1.0, -1.0, -1.0,
    -1.0, -1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0,  1.0, -1.0,
  ];

  // Now pass the list of positions into WebGL to build the
  // shape. We do this by creating a Float32Array from the
  // JavaScript array, then use it to fill the current buffer.

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsCube), gl.STATIC_DRAW);

  // Set up the normals for the vertices, so that we can compute lighting.

  const normalBufferCube = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBufferCube);

  const vertexNormalsCube = [
    // Front
     0.0,  0.0,  1.0,
     0.0,  0.0,  1.0,
     0.0,  0.0,  1.0,
     0.0,  0.0,  1.0,

    // Back
     0.0,  0.0, -1.0,
     0.0,  0.0, -1.0,
     0.0,  0.0, -1.0,
     0.0,  0.0, -1.0,

    // Top
     0.0,  1.0,  0.0,
     0.0,  1.0,  0.0,
     0.0,  1.0,  0.0,
     0.0,  1.0,  0.0,

    // Bottom
     0.0, -1.0,  0.0,
     0.0, -1.0,  0.0,
     0.0, -1.0,  0.0,
     0.0, -1.0,  0.0,

    // Right
     1.0,  0.0,  0.0,
     1.0,  0.0,  0.0,
     1.0,  0.0,  0.0,
     1.0,  0.0,  0.0,

    // Left
    -1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0
  ];

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormalsCube),
                gl.STATIC_DRAW);

  // Now set up the texture coordinates for the faces.

  const faceColorsCube = [
    [0.0,  1.0,  0.0,  1.0],    // Front face: white
    [0.0,  1.0,  0.0,  1.0],    // Back face: red
    [0.0,  1.0,  0.0,  1.0],    // Top face: green
    [0.0,  1.0,  0.0,  1.0],    // Bottom face: blue
    [0.0,  1.0,  0.0,  1.0],    // Right face: yellow
    [0.0,  1.0,  0.0,  1.0],    // Left face: purple
  ];

  // Convert the array of colors into a table for all the vertices.

  var colorsCube = [];

  for (var j = 0; j < faceColorsCube.length; ++j) {
    const c = faceColorsCube[j];

    // Repeat each color four times for the four vertices of the face
    colorsCube = colorsCube.concat(c, c, c, c);
  }

  const colorBufferCube= gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBufferCube);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorsCube), gl.STATIC_DRAW);

  // Build the element array buffer; this specifies the indices
  // into the vertex arrays for each face's vertices.

  const indexBufferCube = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferCube);

  // This array defines each face as two triangles, using the
  // indices into the vertex array to specify each triangle's
  // position.

  const indicesCube = [
    0,  1,  2,      0,  2,  3,    // front
    4,  5,  6,      4,  6,  7,    // back
    8,  9,  10,     8,  10, 11,   // top
    12, 13, 14,     12, 14, 15,   // bottom
    16, 17, 18,     16, 18, 19,   // right
    20, 21, 22,     20, 22, 23,   // left
  ];

  // Now send the element array to GL

  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesCube), gl.STATIC_DRAW);

  result.push({position: positionBufferCube, normal: normalBufferCube, color: colorBufferCube, indices: indexBufferCube});
  return result;
}
</script>
</head>

<body onLoad='runWebGLApp()'>
<div id='top'>
<h1>Projecto de Computa&ccedil;&atilde;o Gr&aacute;fica 1920</h1>
<h2>Exploring the WebGL framework</h2>
<p></p>
</div>

<div id='contents'>
<div id='canvasContainer'>
<canvas id='canvas-element-id' width='800' height='800'>
Your browser does not support the HTML5 canvas element.
</canvas>
</div>
</div>

<div id='bottom'> </div>
<script> 

function initGUIWithCameraSettings(){
    if(camera){ //global variable. Not very orthodox but hey it is JavaScript!
        var pos = camera.position;
        var st = Math.max(pos[0],pos[1] ,pos[2])/100;
        var maxv = 2* Math.max(pos[0],pos[1] ,pos[2]);
        

    }
}

</script>
<script>cview.run(cview.MODE_VIEW);</script>
</body>
</html>